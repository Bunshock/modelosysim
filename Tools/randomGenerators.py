# Random number generators: Inverse transform method

from random import random
import math
import matplotlib.pyplot as plt

# Discrete variables

# Uniform (discrete) distribution: X ~ U[a, b]
def uniformDVA(a, b):
    assert b >= a, 'Invalid bounds!'
    U = random()
    return int(U * (b-a + 1) + a)


# Geometric distribution: X ~ Geom(p)
def geometricVA(p):
    assert 0 <= p <= 1, 'Invalid value of p!'
    U = random()
    return int(math.log(1-U) / math.log(1-p)) + 1


# Bernoulli distribution: X ~ B(p)
def bernoulliVA(p):
    assert 0 <= p <= 1, 'Invalid value of p!'
    U = random()
    return U < p


# Poisson distribution: X ~ P(lamb)
# Optimized version (less comparissons)
def poissonVA(lamb):
    assert lamb > 0
    
    p = math.e ** (-lamb)
    F = p

    # Look for expected value (p_[lamb])
    for j in range(1, int(lamb) + 1 ):
        p *= lamb / j
        F += p
    
    U = random()
    if U >= F:
        j = int(lamb) + 1
        while U >= F:
            p *= lamb / j
            F += p
            j += 1
        return j - 1
    else:
        j = int(lamb)
        while U < F:
            F -= p
            p *= j / lamb
            j -= 1
        return j + 1


# Binomial distribution: X ~ B(n, p)
def binomialVA(n, p):
    c = p / (1-p)
    prob = (1-p) ** n
    
    F = prob
    i = 0
    U = random()

    while U >= F:
        prob *= c * (n-i) / (i+1)
        F += prob
        i += 1
    
    return i

# Generate an array of numbers generated by a given distribution
def generateVA(NVars, distrib, *args):
    x_vec = []
    for _ in range(NVars):
        X = distrib(*args)
        x_vec.append(X)
    return x_vec


# Graph distribution given an array of numbers generated by said
# distribution
def graphVA(x_vec):
    plt.hist(x_vec, color = 'blue', edgecolor = 'black',
         bins = range(min(x_vec), max(x_vec)+2))
    plt.show()


# Other functions

# Given an array a of length N, and a number r with 0 <= r <= N,
# returns a subset of length N of the array a with its elements
# randomly permutated.
def permutation(a, r=None):

    N = len(a)

    r = N if r == None else r
    assert r == None or 0 <= r <= N, 'Invalid value of r!'

    for j in range(N-1, N-1-r, -1):
        index = int((j+1) * random())
        a[j], a[index] = a[index], a[j]

    return a[N-r:]


# Given a function g and a number N > 0, it calculates the average S of the
# first N elements g(a_i) with i=1,...,N, using the Law of Large Numbers
# (LLN) and the Monte Carlo method using N_SIM iterations.
def averageLLN(g, N, N_SIM):
    sum = 0
    for _ in range(N_SIM):
        # Equivalent to uniformDiscrete(1, N)
        U = int(random() * N) + 1
        sum += g(U)
    # Note that Monte Carlo calculates S/N, so we
    # multiply the result by N to get S.
    return sum / N_SIM * N


if __name__ == '__main__':
    NVars = int(input('Input number of samples: '))
    assert NVars > 0, 'NVars should be a positive integer!'

    # Uniform distribution
    a = int(input('Input lower bound (a): '))
    b = int(input('Input lower bound (b): '))
    assert b > a, 'Invalid bounds!'

    x_vec = generateVA(NVars, uniformDVA, *[a, b])
    graphVA(x_vec)

    # Geometric distribution
    pG = float(input('Input Geom variable probability (p): '))
    assert 0 <= pG <= 1

    x_vec = generateVA(NVars, geometricVA, *[pG])
    graphVA(x_vec)

    # Bernoulli distribution
    pB = float(input('Input Bernoulli variable probability (p): '))
    assert 0 <= pB <= 1

    x_vec = generateVA(NVars, bernoulliVA, *[pB])
    graphVA(x_vec)

    # Poisson distribution
    lamb = float(input('Input Poisson variable lambda: '))
    assert lamb > 0

    x_vec = generateVA(NVars, poissonVA, *[lamb])
    graphVA(x_vec)

    # Binomial distribution
    n = int(input('Input Binomial variable n: '))
    pBin = float(input('Input Binomial variable probability (p): '))
    assert n > 0
    assert 0 <= pBin <= 1

    x_vec = generateVA(NVars, binomialVA, *[n, pBin])
    graphVA(x_vec)
    