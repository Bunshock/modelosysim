from random import random
import math

# Discrete variables

# Generic inverse transform method for X
# x: array of X possible values
# p: array of probabilities
def inverseTransformDVA(x, p):
    U = random()
    i, F = 0, p[0]
    while U >= F:
        i += 1
        F += p[i]
    return x[i]


# Uniform (discrete) distribution: X ~ U[a, b]
def uniformDVA(a, b):
    assert b >= a, 'Invalid bounds!'
    U = random()
    return int(U * (b-a + 1)) + a


# Geometric distribution: X ~ Geom(p)
def geometricVA(p):
    assert 0 <= p <= 1, 'Invalid value of p!'
    U = random()
    return int(math.log(1-U) / math.log(1-p)) + 1


# Bernoulli distribution: X ~ B(p)
def bernoulliVA(p):
    assert 0 <= p <= 1, 'Invalid value of p!'
    U = random()
    return U < p


# Poisson distribution: X ~ P(lamb)
# Non-optimized version
def poissonVA(lamb):
    U = random()
    i, p = 0, math.e ** (-lamb)
    F = p
    while U >= F:
        i += 1
        p *= lamb / i
        F += p
    return i


# Optimized version (less comparissons)
def poissonOptimizedVA(lamb):
    assert lamb > 0
    
    p = math.e ** (-lamb)
    F = p

    # Look for expected value (p_[lamb])
    for j in range(1, int(lamb) + 1 ):
        p *= lamb / j
        F += p
    
    U = random()
    if U >= F:
        j = int(lamb) + 1
        while U >= F:
            p *= lamb / j
            F += p
            j += 1
        return j - 1
    else:
        j = int(lamb)
        while U < F:
            F -= p
            p *= j / lamb
            j -= 1
        return j + 1


# Binomial distribution: X ~ B(n, p)
def binomialVA(n, p):
    c = p / (1-p)
    prob = (1-p) ** n
    
    F = prob
    i = 0
    U = random()

    while U >= F:
        prob *= c * (n-i) / (i+1)
        F += prob
        i += 1
    
    return i

# Other functions

# Given an array a of length N, and a number r with 0 <= r <= N,
# returns a subset of length N of the array a with its elements
# randomly permutated.
def permutation(a, r=None):

    N = len(a)

    r = N if r == None else r
    assert r == None or 0 <= r <= N, 'Invalid value of r!'

    for j in range(N-1, N-1-r, -1):
        index = int((j+1) * random())
        a[j], a[index] = a[index], a[j]

    return a[N-r:]


# Given a function g and a number N > 0, it calculates the average S of the
# first N elements g(a_i) with i=1,...,N, using the Law of Large Numbers
# (LLN) and the Monte Carlo method using N_SIM iterations.
def averageLLN(g, N, N_SIM):
    sum = 0
    for _ in range(N_SIM):
        # Equivalent to uniformDiscrete(1, N)
        U = int(random() * N) + 1
        sum += g(U)
    # Note that Monte Carlo calculates S/N, so we
    # multiply the result by N to get S.
    return sum / N_SIM * N


# Generate an array of numbers generated by a given discrete distribution
# 'distrib' with parameters 'args' using 'N_SIM' simulations
def generateDVA(N_SIM, distrib, *args):
    x_vec = []
    for _ in range(N_SIM):
        X = distrib(*args)
        x_vec.append(X)
    return x_vec


if __name__ == '__main__':

    from graph import graphDVA

    N_SIM = int(input('Input number simulation iterations (N_SIM): '))
    assert N_SIM > 0, 'N_SIM should be a positive integer!'

    # Distributions data
    discrete = [
        ['Inverse Transform (discrete) (input values manually)', 'inverseTransformDVA', [
            ('x', 'values arrary'),
            ('p', 'probabilities array')
        ]],
        ['Uniform (Inverse Transform)', 'uniformDVA', [
            ('a', 'lower bound'),
            ('b', 'upper bound')
        ]],
        ['Geometric (Inverse Transform)', 'geometricVA', [
            ('p', 'probability')
        ]],
        ['Bernoulli (Inverse Transform)', 'bernoulliVA', [
            ('p', 'probability')
        ]],
        ['Poisson (Inverse Transform) (non-optimized)', 'poissonVA', [
            ('lambda', 'mean')
        ]],
        ['Poisson (Inverse Transform) (optimized)', 'poissonOptimizedVA', [
            ('lambda', 'mean')
        ]],
        ['Binomial (Inverse Transform)', 'binomialVA', [
            ('n', 'sample size'),
            ('p', 'probability')
        ]]
    ]

    continuous = [

    ]

    # Show available distributions
    distr_type = int(input('Input distribution type (1: discrete, 2: continuous): '))
    distr_type = ['discrete', 'continuous'][distr_type-1]
    print(f'Available {distr_type} distributions:')
    distr_array = locals()[f'{distr_type}']
    for distr_index, distr in enumerate(distr_array):
        print(f'{distr_index}- {distr[0]}')
    
    distr = distr_array[
        int(input('Enter desired distribution number: '))
    ]

    # Auxiliar function to parse numeric arguments
    def interpretedNumberType(x):
        if ',' in x and '.' in x:
            str_arr = x.split(', ')
            num_arr = []
            for s in str_arr:
                num_arr.append(float(s))
            return num_arr
        elif ',' in x:
            str_arr = x.split(', ')
            num_arr = []
            for s in str_arr:
                num_arr.append(int(s))
            return num_arr
        elif '.' in x:
            return float(x)
        else:
            return int(x)

    # Get distribution parameters
    distr_args, params_str = [], ''
    for arg in distr[2]:
        new_arg = interpretedNumberType(
            input(f'Enter {arg[1]} parameter ({arg[0]}): ')
        )
        distr_args.append(new_arg)
        params_str += f'{arg[0]} = {new_arg}   '

    # Graph distribution
    x_vec = generateDVA(N_SIM, globals()[f'{distr[1]}'], *distr_args)
    graphDVA(x_vec, N_SIM, title=f'{distr[0]} with parameters:\n{params_str.strip(' ')}')
